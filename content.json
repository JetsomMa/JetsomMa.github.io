{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2015/01/01/hello-world/"},{"title":"MarkDown使用文档","text":"一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun();","link":"/2019/01/20/MarkDown%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"},{"title":"兼容Vue2和Vue3的长按指令插件","text":"vue本身并未提供长按操作，此插件用于支持vue框架下的长按 此插件做了vue2和vue3版本的兼容，便于用户使用 vue代码中应用[Home.vue]1234567891011&lt;template&gt; &lt;div v-longpress=&quot;longpressFunc&quot;&gt;长按我试试&lt;/div&gt;&lt;/template&gt;export default { methods: { longpressFunc () { alert('长按被触发!') } }} Vue2中引用[main.js]123import Vue from 'vue'import LongPress from '@/common/plugins/long-press';Vue.use(LongPress) Vue3中引用[main.js]123456import { createApp } from 'vue'import App from './App.vue'const app = createApp(App)import LongPress from '@/common/plugins/long-press';app.use(LongPress) 插件代码[long-press.js]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//全局注册长按指令插件export default { install: (app) =&gt; { let optionData = getOptionData(app) if (optionData.option) { app.directive('longpress', optionData.option) }else{ console.warn(&quot;您的vue版本[&quot;+optionData.version+&quot;]尚不能支持[longpress]指令插件！&quot;) } }}//获取指令注册属性参数function getOptionData(app) { //获取vue版本号 var version = app.version if (Number(version.split('.')[0]) === 3) { //输出vue3的指令注册option return {version, option:{ beforeMount(el, binding) { bindFunction(el, binding) }, unmounted(el) { unBindFunction(el) } }} } else if (Number(version.split('.')[0]) === 2) { //输出vue2的指令注册option return {version, option:{ bind: bindFunction, unbind: unBindFunction }} } return {version, option: null}}//注册指令执行函数function bindFunction(el, binding) { // 确保指令入参是个函数 if (typeof binding.value !== 'function') { // 如果指令入参不是函数则输出警告 console.warn(`[longpress:] provided expression is not a function, but has to be`) } // 定时器指针 let pressTimer = null // 操作计时函数 let start = (e) =&gt; { if (e.type === 'click' &amp;&amp; e.button !== 0) { return; } if (pressTimer === null) { pressTimer = setTimeout(() =&gt; { //长按1秒之后，执行函数 binding.value() }, 1000) } } // 销毁计时器 let cancel = () =&gt; { if (pressTimer !== null) { clearTimeout(pressTimer) pressTimer = null } } //定义监听销毁的函数 el.unbindEventListener = () =&gt; { //销毁所有的监听 el.removeEventListener(&quot;mousedown&quot;, start); el.removeEventListener(&quot;touchstart&quot;, start); el.removeEventListener(&quot;click&quot;, cancel); el.removeEventListener(&quot;mouseout&quot;, cancel); el.removeEventListener(&quot;touchend&quot;, cancel); el.removeEventListener(&quot;touchcancel&quot;, cancel); } // 监听到这些事件时候，产生定时器 el.addEventListener(&quot;mousedown&quot;, start); el.addEventListener(&quot;touchstart&quot;, start); // 监听到这些事件时候，移除定时器 el.addEventListener(&quot;click&quot;, cancel); el.addEventListener(&quot;mouseout&quot;, cancel); el.addEventListener(&quot;touchend&quot;, cancel); el.addEventListener(&quot;touchcancel&quot;, cancel);}//注销指令执行函数function unBindFunction(el) { if (el.unbindEventListener) { el.unbindEventListener() }}","link":"/2020/12/31/%E5%85%BC%E5%AE%B9Vue2%E5%92%8CVue3%E7%9A%84%E9%95%BF%E6%8C%89%E6%8C%87%E4%BB%A4%E6%8F%92%E4%BB%B6/"},{"title":"Aframe热力图heatmap组件","text":"功能介绍支持图片渲染和点阵渲染两种格式，且支持平面渲染和立体渲染 源码路径github源码 https://github.com/JetsomMa/heatmap 体验路径热力图体验路径 https://www.mashaojie.cn/github/heatmap/index.html 接口文档 属性 类型 描述 默认值 points array 生成图形的点位数据，为一维数组，与src互斥，且优先级高于src属性 [] show boolean 控制热力图层显示与隐藏 true pointKey string 当为””时候表示points数组中只存储了热力点数据，没有坐标数据，系统将自动分配坐标；否则，则表示热力渲染所取的属性值 “” space string 决定点位数据从[x、y]属性中获取还是从[x, z]属性中获取，为了兼容3D坐标系,当points有长度且pointKey非空时候生效 默认”2D”，也可取值”3D” minValue number points非空时候生效，为过滤阀值，取值0～1之间，单点除以数组中最大值作为比较值，小于阀值则会被置空 0,表示不进行值过滤 gauss number points非空时候生效，为矩阵点进行高斯模糊算法处理的高斯数组阶数 4 heightPointNumber number points非空时候生效，为热力数据高度方向单列点位数，2D时候对应y轴，3D时候对应z轴 1 widthPointNumber number points非空时候生效，为热力数据宽度方向单列点位数，对应x轴 1 heightStep number points非空时候生效，高度方向单点步长，默认单位为原子单位，2D时候对应y轴，3D时候对应z轴 1 widthStep number points非空时候生效，宽度方向单点步长，默认单位为原子单位，对应x轴 1 src asset 图片元素资源的ID值 (e.g. ‘#myImage’) srcOpacity asset 图片元素资源的ID值 (e.g. ‘#myImage’),用于透明过滤背景 palette string/array 热力色阶类型或者数组 ‘redblue’ renderMode string 渲染模式 surface-面模式；particles-点阵模式 ‘surface’ particleSize number 点阵单个点的大小，为小方块，renderMode取值particles时候生效 1.0 ignoreZeroValues boolean 忽略0值，为true时候，0值位置会镂空 true ignoreTransparentValues boolean 忽略小于0的值，为true时候，小于0值位置会镂空 true stackBlurRadius number 设置图像圆润程度，src属性生效时候起作用 0 opacityMin number 最小透明度，取值0～1之间 0 opacityMax number 最大透明度，取值0～1之间 1 注意事项1、点阵属性渲染的优先级高于图片渲染的优先级 联系方式QQ/WeChat：1215458034 参考文献aframe-heatmap3d https://github.com/morandd/aframe-heatmap3d","link":"/2020/11/05/Aframe%E7%83%AD%E5%8A%9B%E5%9B%BEheatmap%E7%BB%84%E4%BB%B6/"},{"title":"js对象Object深挖学习笔记","text":"1、constructor 【构造函数】使用方式：1let retObj = object.constructor； 使用范例：12let object = new Object();console.log(object.constructor); //ƒ Object() { [native code] } 2、hasOwnProperty 【判断是否包含某个直属属性】使用方式：1let retBoolean = object.hasOwnProperty(key)； 使用范例：123456789let object = { name: &quot;mashaojie&quot;, age: 19, sex: &quot;公&quot;}console.log(object.hasOwnProperty(&quot;name1&quot;)); //falseconsole.log(object.hasOwnProperty(&quot;name&quot;)); //true ---hasOwnProperty只检索直属属性console.log(&quot;name&quot; in object); //true ---in会检索继承链属性 3、isPrototypeOf 【判断一个对象是否是另一个对象的原型父对象】使用方式：1let retBoolean = object.isPrototypeOf(subObj); 使用范例：123456789101112131415161718192021222324252627let Person = function(name){ this.name = name; this.sayHey = function(){ console.log(&quot;hey &quot;+ name); }}let Student = function(name){ Person.call(this, name); this.getName = function(){ console.log(name); }}Student.prototype = new Person();Student.prototype.constructor = Student;let student = new Student(&quot;msj&quot;);let person = new Person(&quot;mnz&quot;);student.sayHey(); //hey msjstudent.getName(); //msjperson.sayHey(); //hey mnzconsole.log(Person.prototype.isPrototypeOf(student)); //trueconsole.log(person.isPrototypeOf(student)); //falseconsole.log(student.isPrototypeOf(person)); //false 4、propertyIsEnumerable 【判断某一个属性的值是否可枚举】使用方式：1let retBoolean = object.propertyIsEnumerable(name); 使用范例：123456789101112131415161718192021222324252627282930let array = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];let object = { name: &quot;msj&quot;, age: 20, num: 2, array: array};for(let item in array){ console.log(item);}//0//1//2//3for(let item in object){ console.log(item);}//name//age//num//arrayconsole.log(array.propertyIsEnumerable(0)); //trueconsole.log(array.propertyIsEnumerable(&quot;length&quot;)); //false --length这个属性不太一般啊！console.log(object.propertyIsEnumerable(&quot;name&quot;)); //trueconsole.log(object.propertyIsEnumerable(&quot;age&quot;)); //trueconsole.log(object.propertyIsEnumerable(&quot;num&quot;)); //trueconsole.log(object.propertyIsEnumerable(&quot;array&quot;)); //true 5、toLocaleString 【对象转字符串-目前没发现啥用途】使用方法：1let retString = object.toLocaleString(); 使用范例：12let obj = {name: &quot;msj&quot;};obj.toLocaleString(); //&quot;[object Object]&quot; 6、toString 【对象转字符串-目前没发现啥用途】使用方法：1let retString = object.toString(); 使用范例：12let obj = {name: &quot;msj&quot;};obj.toString(); //&quot;[object Object]&quot; 7、valueOf 【返回对象本身】使用方法：1let myObject = object.valueOf(); 使用范例：12let obj = {};obj.valueOf(); //{} 8、preventExtensions(), seal(), freeze()的区别 方法 修改属性描述 修改属性值 添加属性 其他对象 ✔️ ✔️ ✔️ preventExtensions() ✔️ ✔️ ❌ seal() ✔️ ❌ ❌ freeze() ❌ ❌ ❌","link":"/2019/08/20/js%E5%AF%B9%E8%B1%A1Object%E6%B7%B1%E6%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"js数组Array深挖学习笔记","text":"1、concat 【数组合并】–纯函数使用方式：1let myArray = array.concat(args...); args：参数，可以是数组，也可以是字符串，参数个数不限 使用范例：concat调用不改变原数组 123456789101112131415var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;var arr2 = new Array(3)arr2[0] = &quot;James&quot;arr2[1] = &quot;Adrew&quot;arr2[2] = &quot;Martin&quot;var arr3 = new Array(2)arr3[0] = &quot;William&quot;arr3[1] = &quot;Franklin&quot;let myArray = arr.concat(arr2,arr3); 12var a = [1,2,3];let myArray = a.concat(4,5); 2、constructor 【获取数据类型】这个属性函数存在于任意数据类型的属性中： 使用方式：1let ret = myArray.constructor； 使用范例：此处注意constructor与instanceof的区别，instanceof会顺着原型链的constructor属性进行对比校验，而construct比较的只是当前属性 123[].constructor === Array; //true[].constructor === Object //false&quot;&quot;.constructor === String //true 3、copyWitnin 【复制数组目标元素到指定的位置上】使用方式：1let myArray = array.copyWithin(target, start, end)； 使用范例：1234[1,2,3,4,5].copyWithin(3, 1, 3)&gt; [1, 2, 3, 2, 3][1,2,3,4,5].copyWithin(3, 1, 4) //由此可见此方法不会改变数组的大小&gt; [1, 2, 3, 2, 3] 4、entries 【获取数组的遍历器对象】使用方式：12let iterator = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;].entries();iterator.next(); 使用范例：1234567891011121314let iterator = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;].entries();console.log(iterator.next().value); //[0, &quot;Banana&quot;]console.log(iterator.next().value); //[1, &quot;Orange&quot;]console.log(iterator.next().value); //[2, &quot;Apple&quot;]console.log(iterator.next().value); //[3, &quot;Mango&quot;]//或者使用下面for循环--注意：IE浏览器不支持for...of，需要通过babel做转换for(let item of iterator){ console.log(&quot;item&quot;, item);}//[0, &quot;Banana&quot;]//[1, &quot;Orange&quot;]//[2, &quot;Apple&quot;]//[3, &quot;Mango&quot;] 5、every 【检测数组的每一个元素是否都符合条件】使用方法：1let retBoolean = array.every(function(currentValue,index,arr), thisValue); 使用范例：12[32, 33, 16, 40].every(e =&gt; e &gt; 18); //false[32, 33, 16, 40].every(e =&gt; e &gt; 15); //true 6、fill 【将某一元素替换到数组的指定位置】使用方法：1let myArray = array.fill(value, start, end); 使用范例：会改变原数组 123let myArr = [1,2,3,4,5];myArr.fill(9, 1, 3) //[1, 9, 9, 4, 5][1,2,3,4,5].fill(9, 1, 6) //[1, 9, 9, 9, 9] //由此可见此方法不会改变数组的大小 7、filter 【数组过滤器】–纯函数使用方法：1let myArray = array.filter(function(currentValue,index,arr), thisValue); 使用范例：1234567//使用过滤器元素去重let orgArr = [1,3,2,5,2,9,11,8,15,6,3,5];let myArray = orgArr.filter((e, index, arr) =&gt; { return arr.indexOf(e) == index;});//orgArr &gt; [1, 3, 2, 5, 2, 9, 11, 8, 15, 6, 3, 5]//myArray &gt; [1, 3, 2, 5, 9, 11, 8, 15, 6] 8、find 【查找符合条件的第一个数组元素】使用方法：1let retItem = array.find(function(currentValue,index,arr), thisValue); 使用范例：1let ret = [3, 10, 18, 20].find(e =&gt; e &gt; 16); //18 9、findIndex 【查找符合条件的第一个数组元素的索引】使用方法：1let retNumber = array.findIndex(function(currentValue,index,arr), thisValue); 使用范例：1let retNumber = [3, 10, 18, 20].findIndex(e =&gt; e &gt; 16); //2 10、flat 【多维数组降维—想到了刘慈欣大师的“降维打击”战术策略】使用方法：1let myArray = array.flat(level); level：对多维数组的降维层级 使用范例：123[1, [2, [3, [4, 5]]], 6].flat(); //[1, 2, Array(2), 6][1, [2, [3, [4, 5]]], 6].flat(2); //[1, 2, 3, Array(2), 6][1, [2, [3, [4, 5]]], 6].flat(3); //[1, 2, 3, 4, 5, 6] 11、flatMap 【映射每个元素，然后将结果压缩成一个新数组】此方法默认自带元素操作降维功能，最低反馈一维数组 使用方法：1let myArray = array.flatMap(function(currentValue,index,arr), thisValue); 使用范例：1234567891011[1, 2, 3, 4].flatMap(x =&gt; x * 2); //[2, 4, 6, 8][1, 2, 3, 4].flatMap(x =&gt; [x * 2]); // [2, 4, 6, 8]只会将 flatMap 中的函数返回的数组 “压平” 一层[1, 2, 3, 4].map(x =&gt; [x * 2]); // [[2], [4], [6], [8]][1, 2, 3, 4].flatMap(x =&gt; [[x * 2]]); // [[2], [4], [6], [8]]//虽然上面的代码使用 map 和 flatMap 好像都可以，但这只能展示如何使用 flatMap。//所以，为了更好的展示 flatMap 的作用，下面我们将包含几句话的数组拆分成单个汉字组成的新数组。let arr = [&quot;今天天气不错&quot;, &quot;&quot;, &quot;早上好&quot;]arr.map(s =&gt; s.split(&quot;&quot;)) // [[&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;],[],[&quot;早&quot;, &quot;上&quot;, &quot;好&quot;]]arr.flatMap(s =&gt; s.split(&quot;&quot;));// [&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;, &quot;早&quot;, &quot;上&quot;, &quot;好&quot;] 12、flatten 【数组降维–目前感觉使用和flat一致，未发现差异】使用方法：​ 略 使用范例：1//略 13、forEach 【轮询数组元素】使用方法：1array.forEach(function(currentValue, index, arr), thisValue) 使用范例：123456789101112131415161718192021//改变原来数据的值let myArray = [1,2,3,4,5];//数组值求和范例let sum = 0;myArray.forEach((value, index, arr) =&gt; { sum += value;});console.log(sum);//15//轮询改变数组范例//注意forEach和map的区别，forEach没有返回值；let myArray = [1,2,3,4,5];myArray.forEach((value, index, arr) =&gt; value * 2);console.log(myArray);//[1, 2, 3, 4, 5]myArray.forEach((value, index, arr) =&gt; { arr[index] = value * 2;});console.log(myArray);//[2, 4, 6, 8, 10] 14、from【数组转换】使用方法：1let myArray = Array.from(object, mapFunction, thisValue) 使用范例：1234let myArray = Array.from(&quot;123123&quot;); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]let myArray = Array.from(123123); //[]let myArray = Array.from([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]let myArray = Array.from(&quot;123123&quot;, e =&gt; e*2); //[2, 4, 6, 2, 4, 6] 15、includes 【判断数组是否包含某个值】使用方法：1let boolean = array.includes(searchElement, fromIndex) searchElement：需要检索的元素 fromIndex：起始位置 使用范例：12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true 16、indexOf 【检索数组元素，获取下标】使用方法：1let ret = array.indexOf(searchElement, fromIndex); searchElement：需要检索的元素 fromIndex：起始位置 使用范例：12345[1,2,3,3,4,4,5].indexOf(3); //2[1,2,3,3,4,4,5].indexOf(6); //-1[1,2,3,3,4,4,5].indexOf(3, 1); //2[1,2,3,3,4,4,5].indexOf(3, 3); //3[1,2,3,3,4,4,5].indexOf(3, 4); //-1 17、isArray【判断数据是否为数组类型】使用方法：1let retBoolean = Array.isArray(obj) 使用范例：12345let retBoolean = Array.isArray([1,2,3]); //truelet retBoolean = Array.isArray([]); //truelet retBoolean = Array.isArray({}); //falselet retBoolean = Array.isArray(1); //falselet retBoolean = Array.isArray(&quot;123&quot;); //false 18、join 【数组转字符串拼装】使用方法：1let string = array.join(separator); separator：分隔符，默认取值为”,” 使用范例：123456let retString;retString = [1,2,3,4,5].join(); //&quot;1,2,3,4,5&quot;retString = [1,2,3,4,5].join(&quot;|&quot;); //&quot;1|2|3|4|5&quot;retString = [1,2,3,4,5].join(&quot;&quot;); //&quot;12345&quot;retString = [1,2,3,4,5].join(&quot;\\\\&quot;); //&quot;1\\2\\3\\4\\5&quot; //符号&quot;\\&quot;需要做转译，因此输入为&quot;\\\\&quot;retString = [1,2,3,4,5].join(&quot;/&quot;); //&quot;1/2/3/4/5&quot; 19、keys 【返回数组的索引遍历器，感觉貌似没啥用…】使用方法：1let iterator = array.keys(); 使用范例：123456789//待考究let iterator = [{&quot;Banana&quot;:&quot;123&quot;}, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;].keys();for(let item of iterator){ console.log(&quot;item&quot;, item);}//item 0//item 1//item 2//item 3 20、lastIndexOf 【逆向检索数组元素，获取下标】使用方法：1let retNumber = array.lastIndexOf(searchElement, endIndex); searchElement：需要检索的元素 endIndex：结束位置 使用范例：12345678//这个的理解比较绕，建议理解起来分两步//1、按照结束位置先截取数组【包含结束角标的截取】//2、在截取的数组中找最后一个元素的下标[1,2,3,3,4,4,5].lastIndexOf(3); //3[1,2,3,3,4,4,5].lastIndexOf(6); //-1[1,2,3,3,4,4,5].lastIndexOf(3, 1); //-1[1,2,3,3,4,4,5].lastIndexOf(3, 2); //2[1,2,3,3,4,4,5].lastIndexOf(3, 3); //3 21、map 【对数组中每个元素做处理，然后生成新数组】使用方法：1let myArray = array.map((value, index, arr) =&gt; {}); 使用范例：1let myArray = [1,2,3,4,5].map((value, index, arr) =&gt; value * 2); //[2, 4, 6, 8, 10] 22、pop 【删除数组最后一个元素，并返回】使用方法：1let item = array.pop(); //此方法会改变原来的数组 使用范例：12345let array = [1,2,3,4,5];let item = array.pop();console.log(&quot;item&quot;, item); //item 5console.log(&quot;array&quot;, array); //array [1, 2, 3, 4] 23、push 【给数组末尾添加新元素，并返回新数组长度】使用方法：1let arrayLength = array.push(agrs...); //返回数组长度 使用范例：12345let array = [1,2,3,4,5];let arrayLength = array.pop(&quot;9&quot;, 12, 16);console.log(&quot;arrayLength&quot;, arrayLength); //arrayLength 8console.log(&quot;array&quot;, array); //array [1, 2, 3, 4, 5, &quot;9&quot;, 12, 16] 24、reduce 【单元素操作求和处理】使用方法：1let retNumber = array.reduce(function(sum, value, index, arr), initialValue); 使用范例：12345678910111213//数组指定算法求和[1,2,3,4,5,6].reduce((a,b) =&gt; a+b); //21[1,2,3,4,5,6].reduce((a,b) =&gt; a + b*2); //41 -- a第一次相加表示数组第一个元素[1,2,3,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //42 -- a第一次相加时候为0[1,2,3,,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //42 -- a第一次相加时候为0,空值当作0处理[1,2,3,null,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //42[1,2,3,&quot;&quot;,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //42 -- 字符串做强转，空转为0[1,2,3,&quot;5&quot;,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //52 -- 字符串做强转，空转为0[1,2,3,undefined,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //NaN[1,2,3,NaN,4,5,6].reduce((a,b) =&gt; a + b*2, 0); //NaN 25、reduceRight 【单元素操作求和处理-从右往左处理】使用方法：1let retNumber = array.reduceRight(function(sum, value, index, arr), initialValue); 使用范例：123//reduce和reduceRight使用对比[1,2,3,4,5,6].reduce((a,b) =&gt; a*10+b); //123456[1,2,3,4,5,6].reduceRight((a,b) =&gt; a*10+b); //654321 26、reverse 【数组逆序，并返回新数组】使用方法：1let myArray = array.reverse(); 使用范例：1let myArray = [1,2,3,4,5,9].reverse(); //[9, 5, 4, 3, 2, 1] 27、shift 【删除数组第一个元素生成新数组，并返回元素值】使用方法：1let retItem = array.shift(); //此方法会改变原数组 使用范例：12345let array = [2,3,4,5,6];let retItem = array.shift();console.log(&quot;array&quot;, array); //array [3, 4, 5, 6]console.log(&quot;retItem&quot;, retItem); //retItem 2 28、slice 【数组截取，并返回新数组】使用方法：1let myArray = array.slice(start, end); //索引参数包前不包后 使用范例：1234567let array = [1,2,3,4,5];let myArray = array.slice(1, 3); //slice不改变原数组，返回新数组let myArray2 = array.slice(); //slice不改变原数组，返回新数组console.log(&quot;array&quot;, array); //array [1, 2, 3, 4, 5]console.log(&quot;myArray&quot;, myArray); //myArray [2, 3]console.log(&quot;myArray2&quot;, myArray2);//myArray2 [1, 2, 3, 4, 5] 29、some 【判断时候有元素符合条件】使用方法:1let retBoolean = array.some(function(currentValue,index,arr),thisValue); 使用范例：123[10,11,12,13,14].some((value) =&gt; value &gt; 9); //true[10,11,12,13,14].some((value) =&gt; value &gt; 13); //true[10,11,12,13,14].some((value) =&gt; value &gt; 14); //false 30、sort 【数组按指定方法排序】使用方法：1array.sort(sortfunction) //默认升序处理 使用范例：12345678910111213141516//注意：字母操作只能升序，如需要降序，则先升序，再调用reverse()逆序处理；[&quot;b&quot;,&quot;r&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;,&quot;s&quot;].sort(); //[&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;r&quot;, &quot;s&quot;] --默认字母升序[9,5,8,3,7,4,6,3,5].sort(); //[3, 3, 4, 5, 5, 6, 7, 8, 9][9,5,8,3,7,4,6,3,5].sort((a,b) =&gt; a-b); //[3, 3, 4, 5, 5, 6, 7, 8, 9][9,5,8,3,7,4,6,3,5].sort((a,b) =&gt; b-a); //[9, 8, 7, 6, 5, 5, 4, 3, 3]//注意：排序功能会改变原数组,且不会生成新的数组对象，如下所示：let array = [9,5,8,3,7,4,6,3,5];let myArray = array.sort();console.log(&quot;array&quot;, array); //array (9) [3, 3, 4, 5, 5, 6, 7, 8, 9]console.log(&quot;myArray&quot;, myArray); //myArray (9) [3, 3, 4, 5, 5, 6, 7, 8, 9]myArray.push(10);console.log(&quot;array&quot;, array); //array (9) [3, 3, 4, 5, 5, 6, 7, 8, 9, 10]console.log(&quot;myArray&quot;, myArray); //myArray (10) [3, 3, 4, 5, 5, 6, 7, 8, 9, 10] 31、splice 【数组元素修改，返回被删除的元素数组，改变原有数组】使用方法：12let myArray = array.splice(index, howmany, item1,.....,itemX); //从数组的index位置开始，删除howmany个元素，然后将后续的字元素添加到index位置 使用范例：12345678910111213141516171819202122232425262728//此处要注意一个细节array.splice()和array.splice(0)let array = [1,2,3,4,5,6];let myArray = array.splice(); //从第0位开始，删除0个元素console.log(&quot;array&quot;, array); //array (6) [1, 2, 3, 4, 5, 6] --原数组不变console.log(&quot;myArray&quot;, myArray); //myArray []let array = [1,2,3,4,5,6];let myArray = array.splice(0); //从第0位开始，删除所有元素console.log(&quot;array&quot;, array); //array [] --清空原数组console.log(&quot;myArray&quot;, myArray); //myArray [1, 2, 3, 4, 5, 6]//元素删除范例let array = [1,2,3,4,5,6];let myArray = array.splice(2, 2); console.log(&quot;array&quot;, array); //array [1, 2, 5, 6]console.log(&quot;myArray&quot;, myArray); //myArray [3, 4]//元素添加范例let array = [1,2,3,4,5,6];let myArray = array.splice(2, 0, 9, 9); console.log(&quot;array&quot;, array); //array [1, 2, 9, 9, 3, 4, 5, 6]console.log(&quot;myArray&quot;, myArray); //myArray []//元素删除与添加范例let array = [1,2,3,4,5,6];let myArray = array.splice(2, 3, 9, 9, 9); console.log(&quot;array&quot;, array); //array [1, 2, 9, 9, 9, 6]console.log(&quot;myArray&quot;, myArray); //myArray [3, 4, 5] 32、toLocaleString 【数组转字符串】使用方法：某些情况下等同于toString方法1let retString = array.toLocaleString(); 使用范例：12345678[1,2,3,4,5,6].toLocaleString(); //&quot;1,2,3,4,5,6&quot;//看看toLocaleString和toString的差别let array = [10000, 20000, new Date()];console.log(array.toString());//10000,20000,10000,20000,Fri May 08 2020 15:41:37 GMT+0800 (中国标准时间)console.log(array.toLocaleString());//10,000,20,000,2020/5/8 下午3:41:37 33、toString 【数组元素拼装输出符串，不改变原数组】使用方法：1let retString = array.toString(); 使用范例：12345//元素删除与添加范例let array = [1,2,3,4,5,6];let retString = array.toString(); console.log(&quot;array&quot;, array); //array [1, 2, 3, 4, 5, 6]console.log(&quot;retString&quot;, retString); //retString 1,2,3,4,5,6 34、unshift 【在数组的开头添加一个或更多元素，会改变原数组】使用方法：1let arrayLength = array.unshift(agrs...); //原数组发生改变，返回值为数组长度 使用范例：12345let array = [1,2,3,4,5];let arrayLength = array.unshift(9,9,9,[3,4]);console.log(&quot;array&quot;, array); //array [9, 9, 9, [3,4], 1, 2, 3, 4, 5]console.log(&quot;arrayLength&quot;, arrayLength); //arrayLength 9 35、valueOf【】使用方法：1let ret = array.valueOf(); 使用范例：12345let array = [1,2,3,4,5];let ret = array.valueOf();console.log(&quot;array&quot;, array);console.log(&quot;ret&quot;, ret); 36、values 【返回数组元素的遍历器】使用方法：12//一般可以直接对数组用for...of...方法进行遍历，所以此方法基本很少用到。let iterator = array.values(); 使用范例：1234567891011121314151617let array = [&quot;msj&quot;, &quot;mnz&quot;, &quot;yx&quot;];let iterator = array.values();for(let item of iterator){ console.log(&quot;item&quot;, item);}//item msj//item mnz//item yx//直接遍历数组，执行无差异for(let item of array){ console.log(&quot;item&quot;, item);}//item msj//item mnz//item yx","link":"/2019/08/21/js%E6%95%B0%E7%BB%84Array%E6%B7%B1%E6%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"MAC 笔记本上 XMind 软件破解安装","text":"1、下载 XMind 安装包XMind 安装包下载 下载后的内容如下图所示，其中 dmg 文件 XMind 安装文件【从官网下载的】，XMindCrack.jar 为破解所需的文件。 2、断网并安装 XMind**此时需要切断互联网**，然后通过 dmg 文件安装 XMind 应用，安装成功后打开 XMind 应用。 3、XMind.app 资源修改**在 XMind 应用开启的状态下**，查看 xmind.app 包内容 打开包之后，进入 Contents/Eclipse/文件夹， A、将 XMindCrack.jar 放在这个这个文件夹， B、同时修改 XMind.ini 文件，在后面添加 ​ -javaagent:/Applications/XMind.app/Contents/Eclipse/XMindCrack.jar 4、输入序列号如下图所示，操作 XMind 的菜单，进入序列号激活页， 输入邮箱和序列号，然后尝试重启应用，如能正常启动，则激活成功。 邮箱：随便 序列号： XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLI QMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGR ARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY5 46U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345 特别注意–如果应用打开时候提示“应用已损毁”，大概率是因为操作流程问题或者没有断开互联网，此时请删掉已安装的 XMind 应用，重新进行操作。如果重试依旧失败，请评论区联系作者。","link":"/2020/03/11/MAC%20%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B8%8A%20XMind%20%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3%E5%AE%89%E8%A3%85/"},{"title":"Js浅拷贝理解误区纠正和深拷贝最佳方案","text":"如果条件允许，建议直接使用lodash库 浅拷贝和深拷贝只是针对对象引用类型而言的。因为有C语言和java语言的背景，所以对于对象的指针存储的理解并不难，也知道js现在越来越像java类语言，只是没有想到竟然会如此的像。 我一直以来对浅拷贝的认知误区是：我以为=赋值就是浅拷贝，而我这种认知源于之前看过的一篇误人子弟的博客，也怪了没有去深究，因为出于项目研发解决问题的目的，当时我想重点学习的深拷贝方法已经学到了，也只是附带看了一下浅拷贝的内容，最后得出来一个错误的结论：js某些点还是不如java全面。 反面教材案例【有8W+访问量，不能说一无是处，只能说不够严谨】： https://blog.csdn.net/baidu_36065997/article/details/80309991 我看到的比较好的教材案例【相当深刻，便于理解，却只有1500+的访问量】： https://www.jianshu.com/p/a8dc699e9534 为了做好记录，便于他人学习，我发挥了我不摇碧莲的身手拿来主义【申明一下：我一向尊重原创】 开始学习了学习之前，先了解下堆和栈知识，js 的数据类型 堆和栈的区别其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放; 而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 数据类型 基本数据类型：String、Number、Boolean、Symbol、Undefined、Null 引用数据类型：Object 基本数据类型存放在栈中：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 基本数据类型值不可变：基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的 例如： 123var str = &quot;abc&quot;;console.log(str[1]=&quot;f&quot;); // fconsole.log(str); // abc 引用类型存放在堆中 引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配 引用数据类型值可变： 123var a = [1,2,3];a[1] = 5;console.log(a[1]); // 5 浅拷贝 VS深拷贝 传值和传址（通过基本数据和引用数据类型的却别之后，我们就应该能明白传值与传址的区别了）。 在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中 12345var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响 123456789101112var a = {}; // a保存了一个空对象的实例var b = a; // a和b都指向了这个空对象a.name = 'jozo';console.log(a.name); // 'jozo'console.log(b.name); // 'jozo'b.age = 22;console.log(b.age);// 22console.log(a.age);// 22console.log(a == b);// true 浅拷贝【这一句是重点】看完上面的文章，其实上面的代码是我们常用的赋值引用，还不能算浅拷贝 那么 赋值和浅拷贝有什么区别？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var obj1 = { 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]],};var obj2 = obj1;var obj3 = shallowCopy(obj1);function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst;}obj2.name = &quot;lisi&quot;;obj3.age = &quot;20&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];obj3.language[2] = [&quot;四&quot;,&quot;五&quot;];console.log(obj1); //obj1 = {// 'name' : 'lisi',// 'age' : '18',// 'language' : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj2);//obj2 = {// 'name' : 'lisi',// 'age' : '18',// 'language' : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj3);//obj3 = {// 'name' : 'zhangsan',// 'age' : '20',// 'language' : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//}; obj1 原始数据 obj2 赋值数据 obj3 浅拷贝数据 接下来说下浅拷贝。 为什么改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language） 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。 【因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。】 用一句话简单理解 ： 浅拷贝就是拷贝了一层，除了对象是拷贝的引用类型，其他（一开始讲到的基本数据类型）都是直接将值传递，有自己的内存空间的 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 深拷贝看完对浅拷贝的理解，可以知道：深拷贝就是对对象以及对象的所有子对象进行拷贝。 接下来改探讨的就是如何对对象进行深拷贝？ 1、用 JSON.stringify 把对象转成字符串，再用 JSON.parse 把字符串转成新的对象（使用JSON）。 1234567891011var obj1 = { body: { a: 10 } };var obj2 = JSON.parse(JSON.stringify(obj1));obj2.body.a = 20;console.log(obj1);// { body: { a: 10 } } &lt;-- 沒被改到console.log(obj2);// { body: { a: 20 } }console.log(obj1 === obj2);// falseconsole.log(obj1.body === obj2.body);// false 坏处：它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。所以只适合 Number, String, Boolean, Array 的扁平对象 2、递归拷贝 1234567891011121314151617181920212223242526272829303132function deepClone(obj) { let objClone = Array.isArray(obj) ? [] : {}; if (obj &amp;&amp; typeof obj === &quot;object&quot;) { for (key in obj) { if (obj.hasOwnProperty(key)) { //判断ojb子元素是否为对象，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) { objClone[key] = deepClone(obj[key]); } else { //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone;} var obj1 = { a: 1, b: 2, c: { d: 3 }}var obj2 = deepClone(obj1);obj2.a = 3;obj2.c.d = 4;alert(obj1.a); // 1alert(obj2.a); // 3alert(obj1.c.d); // 3alert(obj2.c.d); // 4 或者使用es6中的 Object.create()方法 12345678910111213141516function deepClone(initalObj, finalObj) { var obj = finalObj || {}; for (var i in initalObj) { var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) { continue; } if (typeof prop === 'object') { //马少杰---20190507---此处修复了源代码的一处错误 obj[i] = (prop.constructor === Array) ? deepClone(prop, []): Object.create(prop); } else { obj[i] = prop; } } return obj;} 最后总结经验总结：学习要严谨技术总结：​ 这块有一个概念，js对象里面包个对象，这个现象在js里面的官话叫js原型链的继承，跟java当中的子类继承父类思想是一样的。一直以来我以为JSON.parse(JOSN.stringify(Object));是最牛逼通用的对象深拷贝方法，今天才知道不是，因为这样做会丢失对象的构造函数。 修补了原博主“使用es6中的 Object.create()方法”深拷贝的一处代码错误 希望各位学习指正，如有疏漏请与我联系：Wechat/QQ：1215458034","link":"/2019/09/20/Js%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%90%86%E8%A7%A3%E8%AF%AF%E5%8C%BA%E7%BA%A0%E6%AD%A3%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%9C%80%E4%BD%B3%E6%96%B9%E6%A1%88/"},{"title":"MAC笔记本降低node的版本","text":"首先搜索您所需的软件包1brew search node 这可能会为您带来以下结果： 12345678heroku/brew/heroku-node ✔llnodenode@10nodebrewleafnodenode ✔node@8.... 然后安装所需的版本1brew install node@8 还要记住，您可以同时安装多个节点软件包，但不能同时使用它们。因此，如果您node已经安装了最新/通用软件包，则需要先取消链接：1brew unlink node 然后，您可以链接其他版本1brew link node@8 对于某些较旧的节点版本（仅桶），可能需要将它们与--force和--overwrite选项链接：1brew link --force --overwrite node@8 特别注意–对于mac本，在完成以上操作之后，可能需要手动配置或更改环境变量【即.bash_profile文件】","link":"/2020/01/20/MAC%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%99%8D%E4%BD%8Enode%E7%9A%84%E7%89%88%E6%9C%AC/"},{"title":"Linux内核升级","text":"1. 关于 Linux 内核1.1 官方内核在使用 Docker 时，发现其对 Linux 内核版本的最低要求是 3.10（这也刚好是 CentOS 7.2 的内核版本），但是在这个版本上有部分功能无法实现。目前 Linux 内核已经发布到 4.X（可以随时在 Linux 内核官网 查看当前版本），为了使用最新版本的内核，只好在安装 CentOS 7 后对内核进行升级。 当然，内核也不能选最新的，防止有尚未发现的 BUG。而且为了减少以后停止维护带来的麻烦，最好安装长期支持版本。各个版本的支持时间在 这个页面 查看。每个版本可能有四种类型，概述如下： Prepatch：Prepatch 或 “RC” 内核是主要的内核预发行版本，主要针对内核开发人员和 Linux 爱好者。必须从源代码进行编译，并且通常包含必须在可以放入稳定版本之前进行测试的新功能。Prepatch 内核由 Linus Torvalds 维护和发布。Mainline：Mainline 主线树由 Linus Torvalds 维护。这个版本的内核会引入所有新功能。新的 Mainline 内核每 2-3 个月发布一次。Stable：每个主线内核被发布后，即被认为是“stable”。任何对 stable 内核的 BUG 修复都会从 Mainline 主线树中回溯并由指定的 stable 内核维护人员使用。 在下一个主线内核可用之前，通常只有几个 BUG 修复内核版本 - 除非它被指定为“longterm maintenance kernel（长期维护内核）”。stable 内核更新按需发布，通常每月 2-3 次。 Longterm：通常会提供几个“longterm maintenance”内核版本，用于修复旧版内核的 BUG。这些内核只会修复重大 BUG，并且不会频繁发布版本。 1.2 各大 Linux 发行版内核一般来说，只有从 kernel.org 下载并编译安装的内核才是官方内核。大多数 Linux 发行版提供自行维护的内核，可以通过 yum 或 rpm 等包管理系统升级。这些内核可能不再和 Linux 内核官方开发维护人员有关系了。通过这个由各大 Linux 发行版支持的仓库升级内核，通常来说更简单可靠，但是可选择的内核版本也更少。 使用 uname -r 区分你用的是官方内核还是 Linux 发行版内核，横线后面有任何东西都表示这不是官方内核： 12# uname -r3.10.0-514.26.2.el7.x86_64 2、查看当前的内核版本2.1 概述Linux 只表示内核。各大 Linux 发行版（RedHat、Ubuntu、CentOS 等）在内核基础上集成了其他的一系列软件，按照各自的版本规则发布。例如 CentOS 7.2 中，通过 uname -r 查看内核版本时，会看到 3.10.0-514.26.2.el7.x86_64，表示对应的 Linux 内核版本是 3.10。 2.2 常用的查看内核信息的命令2.2.1 uname打印指定的系统信息。不带参数时，默认使用 -s 参数。参数：-a, –all：按照下面的顺序打印所有信息，如果 -p 和 -i 未知时排除掉。-s, –kernel-name：打印内核名字，一般就是 Linux。-n, –nodename：打印网络节点的主机名。-r, –kernel-release：打印内核发行版的版本。常用。3.10.0-514.26.2.el7.x86_64-v, –kernel-version：打印内核的版本。#1 SMP Tue Jul 4 15:04:05 UTC 2017-m, –machine：打印机器硬件名。-p, –processor：打印处理器名字或“unknown”。-i, –hardware-platform：打印硬件平台或“unknown”。-o, –operating-system：打印操作系统。–help：显示这个帮助并退出。–version：显示这版本信息并退出。 示例： 123456# uname -r3.10.0-514.26.2.el7.x86_64# uname -aLinux VM_139_74_centos 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) 2.2.2 /proc 虚拟文件系统内核空间和用户空间通过 /proc 虚拟文件系统可以通信。/proc 目录中包含一些目录和虚拟文件，这些虚拟文件可以向用户呈现内核信息或者从用户空间向内核发送信息。常用文件： cpuinfo：标识了处理器的类型和速度pci：显示在 PCI 总线上找到的设备modules：当前加载到内核中的模块 version：系统版本及内核版本 示例： 12# cat /proc/version Linux version 3.10.0-514.26.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) #1 SMP Tue Jul 4 15:04:05 UTC 2017 3. 备份数据4. 升级内核记得首先更新仓库： 12yum -y update-y 选项可以在每次需要确认时，自动使用 yes，节省时间。 4.1 启用 ELRepo 仓库ELRepo 仓库是基于社区的用于企业级 Linux 仓库，提供对 RedHat Enterprise (RHEL) 和 其他基于 RHEL的 Linux 发行版（CentOS、Scientific、Fedora 等）的支持。ELRepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。 启用 ELRepo 仓库： 12# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm 4.2 查看可用的系统内核包:1# yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available 4.3 安装最新内核:12# yum --enablerepo=elrepo-kernel install kernel-ml--enablerepo 选项开启 CentOS 系统上的指定仓库。默认开启的是 elrepo，这里用 elrepo-kernel 替换。 5. 设置 grub2内核安装好后，需要设置为默认启动选项并重启后才会生效 5.1 查看系统上的所有可用内核：1234567# awk -F\\' '$1==&quot;menuentry &quot; {print i++ &quot; : &quot; $2}' /etc/grub2.cfg[root@VM_0_13_centos ~]# awk -F\\' '$1==&quot;menuentry &quot; {print i++ &quot; : &quot; $2}' /etc/grub2.cfg0 : CentOS Linux (5.3.9-1.el7.elrepo.x86_64) 7 (Core)1 : CentOS Linux (3.10.0-1062.4.1.el7.x86_64) 7 (Core)2 : CentOS Linux (3.10.0-957.21.3.el7.x86_64) 7 (Core)3 : CentOS Linux (0-rescue-0ea734564f9a4e2881b866b82d679dfc) 7 (Core) 5.2 设置 grub2我们要使用 5.3.9 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置。 5.2.1. 通过 grub2-set-default 0 命令设置：其中 0 来自上一步的 awk 命令： 1grub2-set-default 0 5.2.2. 编辑 /etc/default/grub 文件设置 GRUB_DEFAULT=0，表示使用上一步的 awk 命令显示的编号为 0 的内核作为默认内核 1234567891011# vi /etc/default/grub&gt; GRUB_TIMEOUT=5&gt; GRUB_DISTRIBUTOR=&quot;$(sed 's, release .*$,,g' /etc/system-release)&quot;&gt; GRUB_DEFAULT=0&gt; GRUB_DISABLE_SUBMENU=true&gt; GRUB_TERMINAL_OUTPUT=&quot;console&quot;&gt; GRUB_CMDLINE_LINUX=&quot;crashkernel=auto console=ttyS0 console=tty0 panic=5&quot;&gt; GRUB_DISABLE_RECOVERY=&quot;true&quot;&gt; GRUB_TERMINAL=&quot;serial console&quot;&gt; GRUB_TERMINAL_OUTPUT=&quot;serial console&quot;&gt; GRUB_SERIAL_COMMAND=&quot;serial --speed=9600 --unit=0 --word=8 --parity=no --stop=1&quot; 5.3 生成 grub 配置文件并重启下一步，通过 gurb2-mkconfig 命令创建 grub2 的配置文件，然后重启： 12sudo grub2-mkconfig -o /boot/grub2/grub.cfgsudo reboot 5.4 验证通过 uname -r 查看，可以发现已经生效了。 12# uname -r4.15.6-1.el7.elrepo.x86_64 6. 删除旧内核（可选)内核有两种删除方式：通过 yum remove 命令或通过 yum-utils 工具。 6.1 通过 yum remove 命令查看系统中全部的内核： 1234567# rpm -qa | grep kernelkernel-tools-libs-3.10.0-514.26.2.el7.x86_64kernel-ml-4.15.6-1.el7.elrepo.x86_64kernel-3.10.0-327.el7.x86_64kernel-tools-3.10.0-514.26.2.el7.x86_64kernel-headers-3.10.0-514.26.2.el7.x86_64kernel-3.10.0-514.26.2.el7.x86_64 删除旧内核的 RPM 包 1yum remove kernel-tools-libs-3.10.0-514.26.2.el7.x86_64 kernel-3.10.0-327.el7.x86_64 kernel-tools-3.10.0-514.26.2.el7.x86_64 kernel-headers-3.10.0-514.26.2.el7.x86_64 kernel-3.10.0-514.26.2.el7.x86_64 6.2 通过 yum-utils 工具如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。 6.2.1 安装1yum install yum-utils 6.2.2 删除1package-cleanup --oldkernels","link":"/2019/09/11/Linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/"},{"title":"小程序项目实施关键技术总结","text":"最近接到公司一个小程序的紧急项目，包含有管理端、服务端和小程序客户端。 没有基版，没有服务器，没有公众号和小程序账号，一切从0开始，要求20天上线，让人很头疼！ 本着做优质产品的原则，这次我将会细细打磨小程序这块的产品。 虽然加班很晚才回来，但还是想学习罗志祥大师的时间管理，能够充分的利用时间，高效的工作。现就对小程序端的一些重点做细致总结。 如果您有更好的方案，欢迎联系探讨，微信/QQ：1215458034 小程体验二维码: H5程序体验鉴赏，请来这里 https://mashaojie.cn/sxxh 【手机上打开食用才有味道】 网站更新时间：2020-06-12 00:27 小程序端的技术选型是uni-app，因为其在端平台编译运行方面有极大优势，且框架比较成熟和稳定 1、解决uni-app中swiper高度自适应问题 【更新：2020-06-06】对这块代码进行重构，解决小程序兼容问题 问题： 在uni-app中swiper的高度默认为150px【其实在很多Vue的UI框架中默认都是150px】，很多网上的资料都是让设置高度100%，然而这并不能解决问题。 解决方案：更改swiper-item的 height:auto; 【原本是100%，适应父元素高度】，然后让swiper-item的内部子元素撑开swiper-item的高度，在元素渲染结束后获取swiper-item的高度，将高度赋值给swiper元素！ 特别注意：此时的swiper-item并没有heigh这个样式属性，而是取其srcollHeight这个样式属性 核心代码： html代码： 12345&lt;swiper :style=&quot;{height: swiperHeight + 'px'}&quot; ref=&quot;newSwiper&quot; id=&quot;newSwiper&quot; @change=&quot;ontabchange&quot;&gt; &lt;swiper-item style=&quot;height:auto;&quot; v-for=&quot;tab in newsList&quot; :key=&quot;tab.id&quot;&gt; &lt;!-- 内部子元素 --&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; js代码： 1234567891011121314151617181920ontabchange(e) { let index = e.target.current || e.detail.current; //当前显示的swiper-item this.newsTabIndex = index;},resetSwiperHeight(){ if(this.newsList.length &gt; 0){ this.$nextTick(() =&gt; { // #ifdef MP-WEIXIN let queryNode = wx.createSelectorQuery().in(this).selectAll(&quot;.swiper-item.news-swiper-item&quot;); queryNode.boundingClientRect((rect)=&gt; { this.swiperHeight = rect[this.newsTabIndex].height; }).exec(); // #endif // #ifdef H5 this.swiperHeight = this.$refs.newSwiper.$children[this.newsTabIndex].$el.scrollHeight; // #endif }); }} 2、不可描述的主屏吸顶/定位到页面指定位置的滑动功能 因为对支付宝的首页交互体验特别有好感，所以想极力做到人家大厂的交互美感 有品质的产品都是很注重交互的 【更新：2020-06-06】对这块代码进行重构，主要解决以下问题： 1、滑动动画卡顿性能问题； 2、小程序上代码的兼容问题； 3、小程序上代码性能问题和调优； ----小程序代码性能问题主要是因为微信小程序本身存在的一点设计上的不合理，小程序为了有更好的性能采用的是双线程架构模式，双线程分别是逻辑线程和虚拟DOM渲染线程，两个线程间通过JSBridge进行交互通讯，而JSBridge性能并不高，如果逻辑线程和渲染线程存在高频率的交互，JSBridge将会成为性能瓶颈，页面将会出现严重的卡顿甚至卡死。而这块代码中onPageScroll会监听页面滚动频繁的回调，从而触发渲染线程重新渲染页面，在H5下没有问题，但在微信小程序中操作体验极差。解决办法不光要加防抖，还要加渲染锁定，使渲染过程中忽略收到的onPageScroll监听。 解决方案： 其实有两种实现方案，在uni-app中有onPageScroll生命周期函数和uni.createIntersectionObserver这个Api方法，最终还是选择了onPageScroll，原因是createIntersectionObserver这个接口讲述的并不是很清晰，不太好理解，虽然尝试了一下能用，但是细节的可控性方面，还是onPageScroll更为实用。 特别注意： 1、onPageScroll这个生命周期函数触发很平凡，所以要做防抖处理，否则页面交互不可控；2、为了更好的性能，加上了渲染锁定。 核心代码： main.vue html代码： 123456789101112131415&lt;!-- 自定义导航头 --&gt;&lt;nav-bar ref=&quot;navBar&quot; id=&quot;navBar&quot; :backState=&quot;2000&quot; :bgColor=&quot;['#0CA054','#29AD66']&quot; fontColor=&quot;#FFF&quot; :title=&quot;headerTitle&quot;&gt;&lt;/nav-bar&gt;&lt;!-- 首页 --&gt;&lt;view id=&quot;homePage&quot;&gt; &lt;!-- 标题头组件 --&gt; &lt;home-title&gt;&lt;/home-title&gt; &lt;!-- 快捷菜单 --&gt; &lt;quick-module&gt;&lt;/quick-module&gt; &lt;!-- 新闻菜单 --&gt; &lt;news-tab ref=&quot;newsTab&quot; id=&quot;newsTab&quot; :newsTabBars=&quot;newsTabBars&quot; :newsTabIndex=&quot;newsTabIndex&quot; @onChange=&quot;onChange&quot;&gt;&lt;/news-tab&gt; &lt;!-- 新闻列表 --&gt; &lt;news-swiper :newsList=&quot;newsList&quot; :newsTabIndex=&quot;newsTabIndex&quot; :scrollHeight=&quot;scrollHeight&quot; @onChange=&quot;onChange&quot; @goDetail=&quot;goDetail&quot; @loadMore=&quot;loadMore&quot;&gt;&lt;/news-swiper&gt; &lt;!-- 悬浮新闻菜单 --&gt; &lt;news-tab :newsTabBars=&quot;newsTabBars&quot; :style=&quot;newsTabStyle&quot; :newsTabIndex=&quot;newsTabIndex&quot; @onChange=&quot;onChange&quot;&gt;&lt;/news-tab&gt;&lt;/view&gt; js代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119data() { return { headerTitle: &quot;&quot;, newsTabBarTop: 0,//吸顶状态下的悬浮新闻菜单栏应该距离页面顶部的高度 newsTabStyle: &quot;display:none;&quot;,//悬浮菜单栏的样式字符串 newsList: [],//新闻内容 newsTabIndex: 0,//当前选中的新闻菜单 scrollHeight: 0,//新闻列表的高度，通过计算得到 transformTime: 150,//吸顶和定位到新闻的转场动画时长 isTop: true,//定位吸顶标志 isLock: false,//scorll锁定 scrollDiff: 40,//过拉参数【单位px】 newsPosition: 0//新闻菜单定位参数【单位px】 };},onReady(){ //获取手机参数 this.modile = uni.getSystemInfoSync(); // #ifdef MP-WEIXIN //获取自定义导航栏的定位信息 let queryNode = wx.createSelectorQuery().in(this); let queryNode1 = queryNode.select(&quot;#navBar&quot;); queryNode1.boundingClientRect((rect)=&gt; { //获取导航栏的高度数据 this.newsTabBarTop = rect.height; }).exec(); //获取页面中新闻菜单的定位信息 let queryNode2 = queryNode.select(&quot;#newsTab&quot;); queryNode2.boundingClientRect((rect)=&gt; { //定位到新闻菜单悬浮时新闻列表的位置 = 页面内新闻菜单到页面顶部的距离 - 自定义导航栏的高度数据 this.newsPosition = rect.top - this.newsTabBarTop; //计算new-swiper新闻列表所要占据的高度 this.scrollHeight = this.modile.windowHeight - 20 - this.newsTabBarTop - rect.height - (this.is_bang?70:60); }).exec(); // #endif //#ifdef H5 //获取导航栏的高度数据 this.newsTabBarTop = this.$refs.navBar.$el.clientHeight; //定位到新闻菜单悬浮时新闻列表的位置 = 页面内新闻菜单到页面顶部的距离 - 自定义导航栏的高度数据 this.newsPosition = this.$refs.newsTab.$el.offsetTop - this.newsTabBarTop; //计算new-swiper所要占据的高度 this.scrollHeight = this.modile.windowHeight - 20 - this.newsTabBarTop - this.$refs.newsTab.$el.clientHeight - (this.is_bang?70:60); //#endif },onPageScroll(el){ if(el.scrollTop &lt; this.scrollDiff){//如果当前位置小于过拉参数，则置顶返回 this.isTop = true; }else if(el.scrollTop &lt; this.newsPosition - 15){//如果当前位置小于新闻元素位置一定范围，则直接隐藏悬浮的新闻菜单 this.tabNo(); }else{//显示悬浮新闻菜单 this.tabFixed(); this.isTop = false; } if(this.isLock || this.tabIndex != 0) return;//如果当前处于渲染锁定状态，则直接返回 if(timer){//防抖 clearTimeout(timer);//清除计时器 } //重新计时 timer = setTimeout(() =&gt; { if(el.scrollTop &lt; this.newsPosition &amp;&amp; el.scrollTop &gt; this.newsPosition-this.scrollDiff){ //如果拉动距离小于scrollDiff这个差值，且在新闻菜单附近，则定位回到新闻菜单 console.log(&quot;小范围-定位新闻菜单&quot;); this.goNews(); }else if(el.scrollTop &gt; 0 &amp;&amp; el.scrollTop &lt; this.scrollDiff){ //如果拉动距离小于scrollDiff这个差值，则定位吸顶 console.log(el.scrollTop); console.log(&quot;小范围-吸顶&quot;); this.goTop(); }else if(el.scrollTop &gt;= this.scrollDiff &amp;&amp; el.scrollTop &lt;= this.newsPosition-this.scrollDiff) { //中间情况的处理--【如果是吸顶状态，则定位到新闻菜单】，【如果在新闻菜单，则定位到吸顶】 if(this.isTop){ console.log(&quot;公共范围-定位新闻菜单&quot;); this.goNews(); }else{ console.log(&quot;公共范围-吸顶&quot;); this.goTop(); } } }, 50);},methods: { //新闻菜单不悬浮 tabNo(){ this.newsTabStyle = &quot;display:none;&quot;; }, //新闻菜单悬浮 tabFixed(){ this.newsTabStyle = &quot;width:100%;position:fixed;background-color:#fff;z-index:20;box-shadow: 0rpx 0rpx 10rpx #cdcdcd;top:&quot;+this.newsTabBarTop+&quot;px;&quot;; }, //页面置顶 goTop(){ this.isTop = true; uni.pageScrollTo({ scrollTop: 0, duration: this.transformTime, selector: &quot;#homePage&quot; }); this.lockScroll(); }, //页面定位到新闻列表 goNews(){ this.isTop = false; uni.pageScrollTo({ scrollTop: this.newsPosition, duration: this.transformTime, selector: &quot;#homePage&quot; }); this.lockScroll(); }, //锁定渲染锁，在页面渲染完成后20毫秒开锁---小程序的页面每秒渲染60次，每次渲染耗时17ms---16.6666...ms lockScroll(){ this.isLock = true; setTimeout(() =&gt; { this.isLock = false; }, this.transformTime + 20); }} 3、html解析插件 推荐链接：https://github.com/jin-yufeng/Parser 这是一款很强大的html解析插件，兼容各个平台的各个版本都有，值得阅览学习。 4、服务端限流【希望有经验的大神给一些更好的建议…】因为最初项目实施的时候，客户对于公告这块的需求只是文本，到后来测试阶段又要求实现图片，再后来发现又有视频的需求【没有明确需求范围的项目就是个无底洞…】，其实图片也还好，但是视频就…不太好了。为了节约成本，根据需求我买的云服务器只有1M带宽，下载速度差不多100k/s【毕竟是不可能超越125k/s，而且还有TPC层网络丢包重传和链路损耗】。 如果视频清晰度不高也还好，但是当我上传了一个30M的mv做测试的时候，卡顿就已然出现了，这还只是单用户访问，多用户同时看视频，服务端会过载，报503，这时候管理端就上不去了。 正常的请求，搞得像DoS攻击一样。。。 在短期内无法更换服务器的情况下，只能是损失性能，确保服务的稳定，于是我在文件服务器配置上加了限流，限制最高下载速度50k/s【这是一个测试经验值，因为我发现设置为70k/s时，网络环境稍差一点，管理端登录偶尔还是会有503错误】 最终，系统整体是稳定了，但是视频的浏览这块客户体验极差。。。","link":"/2020/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"},{"title":"CentOS修改yum镜像地址","text":"163 镜像是国内最好的yum 镜像之一，这里使用的是163的yum 镜像 1、备份镜像1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、进入 镜像目录1cd /etc/yum.repos.d/ 3、备份原来镜像配置1mv CentOS-Base.repo CentOS-Base.repo.backup 4、下载163 镜像1wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 5、修改163镜像文件名1mv CentOS7-Base-163.repo CentOS-Base.repo 6、最后一步，生成缓存12yum clean allyum makecache","link":"/2020/03/08/CentOS%E4%BF%AE%E6%94%B9yum%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/"},{"title":"Linux系统中Docker服务的安装","text":"Linux系统中Docker服务的安装一、查询系统内核版本12# 需要CentOS系统的内核版本高于 3.10uname -r 二、更新yum1yum update 三、执行 sudo yum install -y yum-utils device-mapper-persistent-data lvm2目前尚不清楚这一步是在干嘛 四、设置docker版本列表信息查询路径12# 从docker官网拉取版本列表yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 五、安装方式一：安装默认最新稳定版本1yum -y install docker-ce 方式二：指定版本安装12# 从docker官网拉取版本列表yum list docker-ce --showduplicates | sort -r 12# 安装指定版本的dockeryum install docker-ce-17.03.3.ce-1.el7 六、验证安装结果12# 查询所安装的docker版本docker version 七、启动docker1234# 启动docker服务systemctl start docker# 查看docker版本信息docker version 当看到下面截图中的内容，则表示已启动成功 八、docker使用命令12345678910111213141516# 查看docker镜像docker images# 查询开源镜像docker search mysql# 拉取docker镜像docker pull localhost:5000/nuclein-sampling-queue-phone:0.1.2# 查看正在运行的docker容器docker ps# 查看所有docker容器【包含正在运行的和已经停止运行的】docker container ls --all# 停止某个docker容器运行docker stop f79a36d37e51# 删除某个docker容器docker container rm f79a36d37e51# 启动运行docker容器docker run --name nuclein-sampling-queue-phone -p 8080:80 -d localhost:5000/nuclein-sampling-queue-phone:0.1.2 九、docker安装mysql数据库123456# 查看mysql服务镜像docker search mysql# 拉取镜像docker pull mysql# 启动mysql服务容器docker run --name mysql -v [数据存储地址]:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=[数据库密码] -d mysql:latest 十、docker安装mysql数据库123456789101112131415161718192021222324252627282930313233343536373839# 拉取镜像docker pull nginx# 先第一次启动nginx服务容器docker run --name nginx -p 80:80 -d nginx# 查询nginx容器服务Iddocker ps# 复制关键配置到宿主机mkdir /home/jetsom/mkdir /home/jetsom/nginx/mkdir /home/jetsom/nginx/etc/mkdir /home/jetsom/nginx/etc/conf.d/mkdir /home/jetsom/nginx/logmkdir /home/jetsom/nginx/htmldocker cp 8051e5beaa2f:/etc/nginx/nginx.conf /home/jetsom/nginx/etc/nginx.confdocker cp 8051e5beaa2f:/etc/nginx/conf.d/default.conf /home/jetsom/nginx/etc/conf.d/default.conf# docker cp 8051e5beaa2f:/var/log/nginx/access.log /home/jetsom/nginx/log/access.log# docker cp 8051e5beaa2f:/var/log/nginx/error.log /home/jetsom/nginx/log/error.log# docker cp 8051e5beaa2f:/usr/share/nginx/html/index.html /home/jetsom/nginx/html/index.html# 停止运行现在的nginx容器docker stop nginx# 查询所有docker容器，找到已经停止运行的nginx容器的Id，进行删除docker ps -a # 等同于 docker container ls --all docker container rm nginx/[containerId]# 按照文件夹挂载方式重新启动nginx服务docker run --name nginx -e TZ=&quot;Asia/Shanghai&quot; -p 80:80 -v /home/jetsom/nginx/etc/nginx.conf:/etc/nginx/nginx.conf -v /home/jetsom/nginx/etc/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/jetsom/nginx/html:/usr/share/nginx/html -v /home/jetsom/nginx/log:/var/log/nginx --privileged=true -d nginx# 设置SSL证书的启动方案docker run --name nginx -e TZ=&quot;Asia/Shanghai&quot; -p 80:80 -p 443:443 -v /home/jetsom/nginx/etc/nginx.conf:/etc/nginx/nginx.conf -v /home/jetsom/nginx/etc/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/jetsom/nginx/ssl:/usr/share/nginx/ssl -v /home/jetsom/nginx/html:/usr/share/nginx/html -v /home/jetsom/nginx/log:/var/log/nginx --privileged=true -d nginx# 容器启停指令docker restart nginx # 重启nginxdocker stop nginxdocker start nginx# 进入容器内部命令docker exec -it [containerId/name] /bin/bash # docker exec -it nginx /bin/bash# 退出容器内部命令exit# 查看docker容器启动日志docker logs nginx 十一、安装docker镜像仓库1234567891011121314151617181920212223# 查看registry服务镜像docker search registry# 拉取registry镜像docker pull registry# 查看镜像历史记录docker history registry:latest# 启动registry容器docker run -d -p 5000:5000 --restart=always --name registry registry### 解决pull镜像不成功问题 # 调用命令: docker pull 118.195.236.91:5000/spatial-modelling-data-server:0.1.5 # 报错信息: Error response from daemon: Get &quot;https://118.195.236.91:5000/v2/&quot;: http: server gave HTTP response to HTTPS client### 解决办法: # 1. 编辑docker daemon.json： vim etc/docker daemon.json # 2. 在文件中添加如下内容： { &quot;insecure-registries&quot;: [&quot;192.168.1.26:5000&quot;] } # 3. 重新加载daemon： systemctl daemon-reload # 4. 重启docker： systemctl restart docker 十二、docker-compose up12345678910111213141516171819202122232425262728293031323334353637383940# 启动应用程序# -d：在后台运行服务容器；docker-compose up [options]# 若不使用默认的docker-compose.yml文件# 命令选项# -f：指定使用的compose模板文件，默认为当前目录下的docker-compose.yaml文件，可以多次指定。# -p：指定项目的名称，默认将使用所在目录名称作为项目名。# –verbose：输出更多调试信息。# -v：打印版本信息并退出。docker-compose -f server.yml up -d# 停止应用程序docker-compose down# 构建（重新构建）项目中的服务容器# 命令选项# –force-rm：删除构建过程中的临时容器；# –no-cache：构建镜像过程中不使用cache（这会加长构建过程）；# –pull：始终尝试通过pull来获取更新版本的镜像；docker-compose build [options]# 检测compose文件的错误docker-compose config# 列出项目中所包含的镜像docker-compose images# 列出项目中目前的所有容器docker-compose ps# 删除所有停止状态的服务容器# 选项：# -f：不要求确认移除；# -s：在删除前停止项目中的所有容器；# -v：删除任何附加到容器的匿名卷；docker-compose rm [options]# 重启项目中的服务docker-compose restart# 停止处于运行状态的容器docker-compose stop# 启动被stop的服务容器docker-compose start# 暂停一个服务容器docker-compose pause# 恢复处于暂停状态中的服务docker-compose unpause","link":"/2022/06/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%ADDocker%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"MAC笔记本配置环境变量【操作.bash_profile文件】","text":"1. 在命令行中输入 export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin 这样可以保证命令行命令暂时可以使用。命令执行完之后先不要关闭终端。 如果你的命令行命令可以使用，请直接跳到第2步。 2. 进入当前用户的home目录 cd ~/ 3. 打开.bash_profile并编辑 open .bash_profile 如果.bash_profile文件不存在，则执行创建命令。 创建.bash_profile文件： touch .bash_profile 4. 这样就打开了一个记事本，会显示你之前配置过的path，修改记事本，强烈建议先备份下，然后根据自己需要配置。###123456export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Homeexport ANDROID_HOME=/Users/XXXXX/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/build-tools/28.0.3 export PATH=/usr/local/bin:/usr/local/sbin:~/bin:$PATH 如果是配置node，则在配置最后一行加上 1export PATH=$PATH:/usr/local/opt/node@10/bin 5.command+s保存关闭文件6.使修改后的配置生效命令 source .bash_profile 7.验证环境变量是否配置成功如果是java,在终端输入以下命令 java -version 如果是node,在终端输入以下命令 node -v 当能正常展示版本号，则表示配置成功！","link":"/2020/04/07/MAC%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E3%80%90%E6%93%8D%E4%BD%9C.bash_profile%E6%96%87%E4%BB%B6%E3%80%91/"},{"title":"MarkDown使用文档","text":"一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun();","link":"/2019/01/20/MarkDown%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3%20copy/"},{"title":"Nodejs版本管理工具(nvm安装与使用)","text":"1.nvm 简介nvm(npm version manager )是 npm 的版本管理工具，可以同时管理多个node版本，便于临时切换使用。 2.安装 nvmwindows下载安装github上下载最新版本:https://github.com/coreybutler/nvm-windows/releases mac下载安装（1）install brew打开终端输入下列命令 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; （2）install nvm如果在本地电脑上已经安装了node的话，可以先写在卸载掉。如果是brew命令安装的话，直接使用下列命令卸载即可 1brew uninstall node 下载好brew之后，使用brew 工具下载nvm,在终端输入下列命令 1brew install nvm （3）配置环境变量将下面这段代码添加至你的环境变量，如果用的是base则配置.bash_profile;如果用的是oh-my-zsh则配置.zshrc 1234# This loads nvmexport NVM_DIR=&quot;$HOME/.nvm&quot;export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; 使环境变量生效 123source ~/.bash_profile orsource ~/.zshrc 3.使用nvm命令123456nvm --version #查询nvm版本信息nvm ls-remote #查看服务器上所有node可用的版本nvm install 12 #安装大版本为12的node的最新版本【一般都是安装LTS的稳定版本】nvm ls #查看本地安装的node版本列表nvm use [XX.xx.xx] #临时切换到指定版本的node【版本号为本地版本号】nvm alias default [XX.xx.xx] #永久切换到指定版本的node【版本号为本地版本号】","link":"/2021/01/19/Nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7(nvm%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8)/"},{"title":"MAC升级Nodejs和Npm到最新版","text":"第一步，先查看本机node.js版本：1node -v 第二步，清除node.js的cache：1sudo npm cache clean -f 第三步，安装 n 工具，这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 “n”1sudo npm install -g n 第四步，安装最新版本的node.js1sudo n stable 第五步，再次查看本机的node.js版本：1node -v 第六步，更新npm到最新版：1$ sudo npm install npm@latest -g 第七步，验证12node -vnpm -v 原文出处作者：南方帅链接：https://www.jianshu.com/p/71c82fc63522来源：简书","link":"/2020/03/20/MAC%E5%8D%87%E7%BA%A7Nodejs%E5%92%8CNpm%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88/"},{"title":"Nodejs镜像源管理工具(nrm安装与使用)","text":"1.nrm 简介nrm(npm registry manager )是 npm 的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换 2.安装 nrm在命令行执行命令，全局安装 nrm。 1npm install -g nrm 3.增加 npm 的镜像源你可以增加定制的源，特别适用于添加企业内部的私有源，执行命令，其中 reigstry 为源名，url 为源的路径。 1nrm add &lt;registry&gt; &lt;url&gt; 例如：新增 goose 镜像源 nrm add goose http://goose.nineheaven.top:4873/ 4.查看 npm 的镜像源执行命令，查看可选的源。其中，带*的是当前使用的源，上面的输出表明当前源是官方源。 1nrm ls 例如： nrm ls npm ——– https://registry.npmjs.org/ yarn ——- https://registry.yarnpkg.com/ cnpm ——- http://r.cnpmjs.org/ * taobao —– https://registry.npm.taobao.org/ nj ——— https://registry.nodejitsu.com/ npmMirror – https://skimdb.npmjs.com/registry/ edunpm —– http://registry.enpmjs.org/ goose —— http://goose.nineheaven.top:4873/ 5.切换 npm 的镜像源如果要切换镜像源，执行命令。其中 reigstry 为源名 1nrm use &lt;registry&gt; 例如：切换到 goose 镜像源 nrm use goose 6.测试镜像源速度你还可以通过 nrm test 测试相应源的响应时间。其中 reigstry 为源名 1nrm test &lt;registry&gt; 例如：测试 goose 镜像源速度 nrm test goose 7.删除 npm 的镜像源执行命令，删除对应的源。其中 reigstry 为源名 1nrm del &lt;registry&gt; 例如：删除 goose 的镜像源 nrm del goose","link":"/2019/07/21/Nodejs%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7(nrm%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8)/"},{"title":"nodejs服务后台持久化运行","text":"forever是一个nodejs守护进程，完全由命令行操控。forever会监控nodejs服务，并在服务挂掉后进行重启。 pm2的命令规则和forever一致，只需要将forever命令替换成pm2即可 1、安装 forever1npm install forever -g 2、配置环境变量a、查找forever服务路径 1find / -name forever b、打开环境变量配置文件 1vim ~/.bash_profile c、添加环境变量配置 123456PATH=$PATH:$HOME/bin###新添加代码PATH=$PATH:/root/nodejs/bin/###新添加代码完毕export PATH d、使环境变量配置生效 1source ~/.bash_profile 3、启动服务1service forever start 4、使用 forever 启动 js 文件1forever start index.js 5、停止 js 文件1forever stop index.js 6、启动js文件并输出日志文件1forever start -l forever.log -o out.log -e err.log index.js 7、重启js文件1forever restart index.js 8、查看正在运行的进程1forever list","link":"/2020/12/22/nodejs%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%8F%B0%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%90%E8%A1%8C/"},{"title":"Object.assgin特性记录","text":"参照原著作者：帅气滴糟老头链接：https://www.jianshu.com/p/d5f572dd3776 使用规则1Object.assign(target, source...); 使用范例123456789101112let object1 = { a:1, b:2};let object2 = { c:3};let object = Object.assign({}, object1, object2);console.log(object1); //{a: 1, b: 2}console.log(object2); //{c: 3}console.log(object); //{a: 1, b: 2, c: 3} 特性1、元素覆盖特性说明：如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性，且这种覆盖发生在直属属性层。 1234567891011121314//范例1let target = { a: 1, b: 1 };let source1 = { b: 2, c: 2 };let source2 = { c: 3 };let object = Object.assign(target, source1, source2);console.log(object); // {a:1, b:2, c:3}//范例2let source = { a: { b: 1, c: 1 }, d: 1 };let source1 = { a: { b: 2 } };let object = Object.assign(source, source1);console.log(object); // { a: { b: 2 }, d: 1 } 2、类型转换合并 忽略数值和布尔值 字符串转成字符串数组再转对象合并 undefined和null在target位置会报错，在source位置会被忽略 数组当成对象处理，返回数组 123456789Object.assign({a : 1, b : 2}, {c : 3}, 9, true, {d : 4}); //{a: 1, b: 2, c: 3, d: 4}Object.assign({a : 1, b : 2},&quot;12ab&quot;);//{0: &quot;1&quot;, 1: &quot;2&quot;, 2: &quot;a&quot;, 3: &quot;b&quot;, a: 1, b: 2}Object.assign(undefined); //Uncaught TypeError: Cannot convert undefined or null to objectObject.assign(null); //Uncaught TypeError: Cannot convert undefined or null to objectObject.assign({a : 1, b : 2}, {c : 3}, undefined, null); //{a : 1, b : 2, c : 3}Object.assign([1, 2, 3], [4, 5]); //[4 , 5, 3] 3、浅拷贝12345678const obj1 = {a: {b: 1}, c: 1};let obj = Object.assign({}, obj1);obj1.a.b = 2;obj1.c = 2;console.log(obj1); //{a: {b: 2}, c: 2}console.log(obj); //{a: {b: 2}, c: 1} 4、对象数组字符串混合合并1234//source位置上的数据类型决定合并后的最终数据类型【数组or对象】Object.assign([1, 2, 3], [4, 5], &quot;123&quot;); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]Object.assign({}, [1, 2, 3], [4, 5], &quot;123&quot;); //{0: &quot;1&quot;, 1: &quot;2&quot;, 2: &quot;3&quot;}Object.assign({a: 1, b: 2}, [1, 2, 3], [4, 5]); //{0: 4, 1: 5, 2: 3, a: 1, b: 2} 5、取值函数的处理123456//如果要复制的值是一个取值函数，那么将求值后再复制。let source = { get foo() { return 1 }};Object.assign({}, source); // { foo: 1 } 典型使用场景1、为对象添加属性12345class Point { constructor(x, y) { Object.assign(this, {x, y}); }} 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 2、为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, { someMethod(arg1, arg2) { ··· }, anotherMethod() { ··· }});// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) { ···};SomeClass.prototype.anotherMethod = function () { ···}; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 3、浅拷贝对象123function clone(origin) { return Object.assign({}, origin);} 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) { let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);} 12345678910111213141516171819202122//测试案例function Person(name){ this.name = name;}function Student(name, age){ Person.call(this, name); this.age = age;}function clone(student){ let o = Object.getPrototypeOf(student); return Object.assign(Object.create(o), student);}let stu1 = new Student(&quot;msj&quot;, 10);let stu2 = Object.assign({}, stu1);let stu3 = clone(stu1);console.log(stu1);console.log(stu2);console.log(stu3); 测试截图： 4、合并多个对象将多个对象合并到某个对象。 1const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 1const merge = (...sources) =&gt; Object.assign({}, ...sources); 5、为属性指定默认值123456const DEFAULTS = { logLevel: 0, outputFormat: 'html'};options = Object.assign({}, DEFAULTS, options);","link":"/2020/01/20/Object.assgin%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%95/"},{"title":"Nginx服务器搭建（支持https）","text":"一、安装nginx1、编译环境依赖 12# gcc和 gcc-c++yum -y install gcc gcc-c++ 2、安装包及依赖包nginx-1.13.12.tar.gz(安装包)、 openssl-1.0.1t.tar.gz(https请求依赖)、 pcre-8.39.tar.gz、(nginx的rewrite依赖) zlib-1.2.11.tar.gz 3、新建nginx用户使用root用户执行useradd nginx 为nginx用户设置密码 passwd nginx 4、上传安装包及依赖包到nginx用户并解压tar -zxvf nginx-1.13.12.tar.gz tar -zxvf openssl-1.0.1t.tar.gz tar -zxvf pcre-8.39.tar.gz tar -zxvf zlib-1.2.11.tar.gz 5、编译依赖环境cd openssl-1.0.1t 执行./config 执行make 执行sudo make install (需要root权限执行此命令) cd pcre-8.39 执行./configure 执行make 执行sudo make install (需要root权限执行此命令) 完成之后执行./pcre-config –-version查看pcre版本 cd zlib-1.2.11 执行./configure 执行make 执行sudo make install(需要root权限执行此命令) 6、安装nginxcd nginx-1.13.12 执行 123456789101112# ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-http_realip_module --with-http_sub_module --with-pcre./configure --prefix=/usr/local/nginx //指定nginx的安装目录 --with-http_stub_status_module //使ngx_stub_status_module 模块可用 --with-http_ssl_module //使用https协议模块 --with-http_gzip_static_module //使nginx支持gzip资源的部署 --with-http_realip_module --with-http_sub_module --with-openssl //读取openssl库的源码路径 --with-pcre //读取pcre库的源码路径 --user=nginx //设置nginx工作进程的用户 --group=nginx //设置nginx的工作进程的用户组 执行make 执行make install 二、配置nginx1、配置证书和秘钥在nginx/conf下新建文件夹cfssl，将证书和秘钥文件放在此目录下 2、修改配置文件vi nginx/conf/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#运行用户user nginx;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志及PID文件#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;#工作模式及连接数上限events { #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections/4 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和 # 系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535}http { #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6].&quot;; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; map $http_upgrade $connection_upgrade { default upgrade; '' close; } #出口（短连接） upstream hostIp { server 3.1.11.76:8869; server 3.1.11.73:8869; } #出口（长连接） upstream websocket { server 3.1.11.76:53005; server 3.1.11.73:53005; } #排队机资源更新出口 upstream gengxingIp { server 3.1.11.76:53006; server 3.1.11.73:53006; } # location 匹配规则 # ~ 波浪线表示执行一个正则匹配，区分大小写 # ~* 表示执行一个正则匹配，不区分大小写 # ^~ 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 # = 进行普通字符精确匹配 #pad调用服务的https请求入口，对应pad的C端配置的hostIp端口（短连接） server { listen 8870 ssl; ssl_certificate /home/nginx/nginx/conf/cfssl/server.crt; ssl_certificate_key /home/nginx/nginx/conf/cfssl/rsa_private_key.pem; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; #proxy_pass [http://hostIp](http://hostip/); #proxy_http_version 1.1; } } #pad调用服务的http请求入口，对应pad的C端配置的websocket端口（长连接） server { listen 54005; location / { proxy_pass [http://websocket](http://websocket/); proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } #排队机http请求(短连接) server { listen 8871; location / { root html; index index.html index.htm; #proxy_pass [http://hostIp](http://hostip/); #proxy_http_version 1.1; #proxy_set_header Upgrade $http_upgrade; #proxy_set_header Connection $connection_upgrade; } } #排队机资源更新请求(短连接) server { listen 54006; location / { proxy_pass [http://gengxingIp](http://gengxingip/); proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } }} 3、校验配置文件的正确性，并启动nginx执行命令进去nginx控制文件路径 cd nginx/sbin 执行./nginx -t 校验配置是否正确 如果提示 1nginx: [warn] the &quot;user&quot; directive makes sense only if the master process runs with super-user privileges, ignored in /usr/local/nginx/conf/nginx.conf:2 可以设置nginx脚本仅 root 用户和 nginx用户可以运行，建议将nginx用户加入到root权限来启动 chown root.nginx nginx chmod 775 nginx chmod u+s nginx #-u：User，即文件或目录的拥有者 ;-s :在文件执行时把进程的属主或组ID置为该文件的文件属主 在sbin目录下执行常用命令： ./nginx 启动nginx ./nginx -s reload 重启nginx ./nginx -s quit 关闭nginx","link":"/2019/10/13/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E6%94%AF%E6%8C%81https%EF%BC%89/"},{"title":"ReactNative框架下自签SSL证书请求被拦截的最佳解决方案","text":"问题场景​使用自签证书的服务端，在RN框架下客户端发送https请求会被拦截，从而导致服务端收不到请求。网上查找了很多解决办法，但在我看来都并非最佳方案，为此做以纪录！ 其实解决方法的代码，互联网上都是有的，本猿之所以写这篇文章，只是因为本猿恬不知耻的觉得本猿的解决方法更好一下 解决这个问题我认为分两部分1、解决问题的方法2、解决问题的更好的方法解决问题的方法我亲测可用的方案，代码如下所示：https://www.jianshu.com/p/ec4abc6a649a【特别鸣谢作者eyow的乐于分享】 为了防止原作者文献的丢失，我将会在另一片文章中将关键代码摘要出来，这里就不做赘述了。 首先，这样的代码和操作是可以解决问题的，IOS的修改可以做的一劳永逸，但是安卓的解决方式却并不友好。 在我们成功的在安卓打包工程中引入了ReactAndroid模块之后，因为RN模块是整个工程的根本，其他每个模块都有引用，如下图所示： 也就是说，我们要将每个RN插件的build.gradle配置中react-native的引用都要修改为：compile project(‘:ReactAndroid’)； 甚至于我们重新npm install之后要改打包壳代码，我们新增一个RN插件之后也要对应的修改打包壳中的build.gradle的引用代码。 这样并不友好！ 解决问题的更好的方法 有时候，对事物的完美要求和对现状的不满足是促使我们成长和发展的一大要素 我们回到npm引用的资源的node_modules路径下react-native中看一眼，如下图所示： 不难发现，原本react-native的引用实际上引用的是如图的这堆jar包和aar包，我们只要修改的jar包和aar包中对应的地方的代码，问题就解决了！ 所以第一个想到的是反编译，修改后再打回对应的jar包和aar包。【这个想法太天真，当看到.md5和.sha1这些文件的时候，有足够开发经验的人都知道，这是防篡改的】 再理一理思路：1、既然安卓的源码我们都有了，那么我们导出上面的jar包和aar包也就变得有可能了；2、这些包的文件结构很眼熟啊，在哪里见过呀——-这不就是maven么！【有时候在做SpringBoot项目的时候，会导致Maven构建项目失败，其中最常见的应该是引用ojdbc6的时候，因为这个jar是Maven仓库自己下载不下来的，需要我们手动下载，然后mvn install到我们的maven仓库中，细心的人会去翻看本地Maven仓库！】 此时的作者灵光一闪，凭借自己多年的临床经验，用自己的脚趾头想了一想，然后一拍大腿惊喊到——这事能弄！ 我们玩过安卓Cordova壳开发的都知道，安卓项目是用gradle构建的，也可以通过写gradle脚本将一个安卓模块导出成为一个aar引用资源包或者一个jar，那么这个maven库导出的代码应该也在gradle配置文件里面！ 当中有四个构建资源下载特别慢，及其耗时，而且容易出错，于是我在别人的百度云盘里找到了对应资源上传到了我的资源服务器，并改了资源下载的脚本，才确保了ReactAndroid模块能够正常高效的构建：【有需要解决这一问题的小伙伴可以微信联系我，我愿意共享代码和我文件服务器上的资源文件。微信/QQ：1215458034】如下图所示： 按照上面的思路，完成这件事儿基本上分为两步：1、修改gradle脚本；2、运行gradle脚本1、修改gradle脚本；顺着上面的思路耐心找一找，果真还给找到了相关配置，如下图所示： 再上图中我们看到了两个很重要的配置路径：1、aar本地资源输出的路径；2、Maven仓库的路径。 所以做这件事儿的前提是你得有一个Maven仓库！ 资源输出的路径，根据自己的需要去修改，Maven仓库的路径改成自己本地maven仓库的地址！ 以下为我的配置修改结果，如图所示： 2、运行gradle脚本运行之前，我们要先找到对应关键的gradle的task！ 经过我耐心的研读寻找，也确实找到了，如下图所示： 我们需要先运行assemble，让基础模块进行组装编译，然后再运行uploadArchives生成Maven库资源，然后再运行installArchives【在other目录里面】导出Maven资源 运行结束后，我们会在对应的位置生成对应的aar包和jar包，如下图所示，此时我们只需要将aar和jar包对应的覆盖到我们的node_modules/react-native目录下即可！ 总结：工作是一种态度，也是一种爱好。虽然现在市面上都在流行前后端分离，讲求技术的专业性，然而跨界并不是什么坏事，有时能更好的解决问题，产生意想不到的效果。所以我们要足够努力，且有必要的自我肯定！","link":"/2020/04/20/ReactNative%E6%A1%86%E6%9E%B6%E4%B8%8B%E8%87%AA%E7%AD%BESSL%E8%AF%81%E4%B9%A6%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%9A%84%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"php安装踩坑","text":"1.安装php的命令123456789101112131415# 下载php压缩包，然后解压缩tar -xzvf XXXXXX.tar.gzcd XXXXXX#安装php8.0.1./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=www --with-fpm-group=www --enable-mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-mysqlnd-compression-support --with-zlib --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --with-curl --enable-mbregex --enable-mbstring --enable-intl --enable-ftp --enable-gd-jis-conv --with-openssl --with-mhash --enable-pcntl --enable-sockets --enable-soap --with-gettext --disable-fileinfo --enable-opcache --with-pear --with-ldap=shared --without-gdbm#安装php7.2以下版本./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=www --with-fpm-group=www --enable-mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-mysqlnd-compression-support --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --enable-intl --with-mcrypt --with-libmbfl --enable-ftp --with-gd --enable-gd-jis-conv --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --with-gettext --disable-fileinfo --enable-opcache --with-pear --enable-maintainer-zts --with-ldap=shared --without-gdbm#安装php7.3版本./configure --prefix=/usr/local/php73 --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib --enable-fpm --enable-bcmath -enable-inline-optimization --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvshm --enable-sysvmsg --enable-sysvsem --enable-xml --enable-zip --with-fpm-user=nginx --enable-ftp --enable-exif --enable-session --with-mhash --with-ldap#安装make &amp;&amp; make install 2.php-fpm操作相关命令1234567891011/usr/local/php/bin/php-fpm #开启 php-fpmps aux|grep php-fpm #查询php-fpm进程kill -USR2 [PID] #重启php-fpmpkill php-fpm #杀死php-fpm进程php -v #查看版本export PATH=/usr/local/php73/bin:$PATH #切换php版本# 修改环境变量vim /etc/profile# 使环境变量生效source /etc/profile 3.PHP编译安装问题解决 PHP 7+ 版本极大地改进了性能，在一些WordPress基准测试当中，性能可以达到PHP 5.6的3倍。而PHP 5.6版本在2018年底官方已经不再维护，升级PHP 7是必然选择。 *** centos7 编辑安装php遇到的问题：*** 解决 configure: error: no acceptable C compiler found in $PATH 错误1yum install -y gcc gcc-c++ 解决 error: the HTTP XSLT module requires the libxml2/libxslt 错误12yum -y install libxml2 libxml2-devyum -y install libxslt-devel 解决 error: the HTTP image filter module requires the GD library. 错误1yum -y install gd-devel 解决 error: the GeoIP module requires the GeoIP library. 错误1yum -y install GeoIP GeoIP-devel GeoIP-data 解决 error: the Google perftools module requires the Google perftools 错误1yum -y install gperftools 解决 error: libatomic_ops library was not found. 错误1yum -y install libuuid-devel libblkid-devel libudev-devel fuse-devel libedit-devel libatomic_ops-devel 解决 error trying to exec ‘cc1plus’: execvp: No such file or directory 错误1yum -y install gcc-c++ 解决 error: [pool www] cannot get uid for user ‘www-data’ 错误12groupadd www-datauseradd -g www-data www-data 解决configure: error: mbed TLS libraries not found. 错误。1234567891011121314151617# 需要安装mbedtls# 1、下载并解压wget https://tls.mbed.org/download/mbedtls-2.16.3-gpl.tgztar -xf mbedtls-2.16.3-gpl.tgzcd mbedtls-2.16.3# 备用下载地址：https://down.24kplus.com/linux/mbedtls/mbedtls-2.16.3-gpl.tgz# 2、编译安装makemake DESTDIR=/usr installldconfig# 如果出现 make[1]: python2: Command not found 错误，执行：yum -y install python2# 如果出现 /usr/bin/env: ‘perl’: No such file or directory 错误，执行：yum -y install perl 解决 error: Cannot find OpenSSL’s &lt;evp.h&gt; 错误12yum install openssl openssl-develln -s /usr/lib64/libssl.so /usr/lib/ 解决 error: Libtool library used but ‘LIBTOOL’ is undefined 错误1yum install libtool 解决 exec: g++: not found 错误12yum -y update gccyum -y install gcc+ gcc-c++ 解决 configure: error: tss lib not found: libtspi.so 错误1yum install trousers-devel 解决 Can’t exec “autopoint”: No such file or directory 错误1yum install gettext gettext-devel gettext-common-devel 解决 configure: error: libcrypto not found. 错误12yum remove openssl-develyum -y install openssl-devel 解决 configure: error: Package requirements (libffi &gt;= 3.0.0) were not met: No package ‘libffi’ found 错误1yum install libffi-devel 解决 fatal error: uuid.h: No such file or directory 错误1yum install e2fsprogs-devel uuid-devel libuuid-devel 解决 configure: error: openssl lib not found: libcrypto.so 错误1yum install openssl-devel 解决 tar (child): lbzip2: Cannot exec: No such file or directory 错误1yum -y install bzip2 解决 configure: error: C++ preprocessor “/lib/cpp” fails sanity check 错误1yum install gcc-c++ 解决 configure: error: Please reinstall the BZip2 distribution 错误1yum install bzip2 bzip2-devel 解决 configure: error: cURL version 7.15.5 or later is required to compile php with cURL support 错误1yum install curl-devel 解决 configure: error: not found. Please provide a path to MagickWand-config or Wand-config program 错误1yum install ImageMagick-devel 解决 configure: error: no acceptable C compiler found in $PATH 错误1yum install gcc 解决 configure: error: Package requirements (icu-uc &gt;= 50.1 icu-io icu-i18n) were not met: 错误1yum install libicu-devel 解决 configure: error: Package requirements (sqlite3 &gt; 3.7.4) were not met: No package ‘sqlite3’ found 错误1yum install sqlite-devel 解决 configure: error: Package requirements (oniguruma) were not met: No package ‘oniguruma’ found 错误123456789101112131415yum install oniguruma oniguruma-devel#使用源代码安装。wget https://github.com/kkos/oniguruma/archive/v6.9.4.tar.gz -O oniguruma-6.9.4.tar.gz tar -zxvf oniguruma-6.9.4.tar.gzcd oniguruma-6.9.4/./autogen.sh./configuremakesudo make install# 解决 bash: make: 未找到命令…# 需要安装gcc，执行一下就可以了：yum -y install gcc automake autoconf libtool makeyum install gcc gcc-c++ 解决 configure: error: Package requirements (libzip &gt;= 0.11 libzip != 1.3.1 libzip != 1.7.0) were not met:Package ‘libzip’, required by ‘virtual:world’, not foundPackage ‘libzip’, required by ‘virtual:world’, not foundPackage ‘libzip’, required by ‘virtual:world’, not found 123456789101112131415161718192021222324# 第一步：rpm -q libzip rpm -q libzip-devel 查看是否有安装过，如果有，卸载它。yum remove libzip-devel libzip# 第二步:# 下载wget https://libzip.org/download/libzip-1.7.3.tar.gz# 解压tar -xvf libzip-1.7.3.tar.gz# 安装cmake3yum install -y cmake3sudo ln -sf /usr/bin/cmake3 /usr/bin/cmake#安装libzipcd libzip-1.7.3/mkdir build &amp;&amp; cd buildcmake ..make &amp;&amp; make install# 源码地址https://pkgs.org/search/?q=libzip#通过源码安装yum install http://mirror.centos.org/centos/8/AppStream/x86_64/os/Packages/libzip-1.5.2-1.module_el8.2.0+314+53b99e08.x86_64.rpmyum install http://mirror.centos.org/centos/8/AppStream/x86_64/os/Packages/libzip-devel-1.5.2-1.module_el8.2.0+314+53b99e08.x86_64.rpm 解决 No package ‘libxml-2.0’ found缺失libxml2.0 库，错误：12yum -y install libxml2yum -y install libxml2-devel 解决 configure: error: Package requirements (libxslt &gt;= 1.1.0) were not met:No package ‘libxslt’ found 错误1yum install libxslt-devel 解决 configure: error: Package requirements (libpng) were not met:No package ‘libpng’ found 错误1yum install libpng-devel 解决 configure: error: Cannot find ldap.h 错误12yum install openldapyum install openldap-devel 解决 configure: error: Cannot find ldap libraries in /usr/lib 错误1cp -frp /usr/lib64/libldap* /usr/lib/ 解决 configure: error: Package requirements (libcurl &gt;= 7.15.5) were not met: 错误1yum install libcurl-devel 解决 configure: error: Package requirements (krb5-gssapi krb5) were not met:1yum -y install krb5-devel 解决 configure: error: Package requirements (libjpeg) were not met:1yum install -y libjpeg-devel 解决 configure: error: Package requirements (freetype2) were not met:1yum -y install freetype freetype-devel 解决 configure: error: Package requirements (libpcre2-8 &gt;= 10.30) were not met:12345678910111213wget https://ftp.pcre.org/pub/pcre/pcre2-10.35.tar.gztar xzvf pcre2-10.35.tar.gzcd pcre2-10.35./configure --prefix=/usr/local/pcre2 \\--enable-pcre2-16 \\--enable-pcre2-32 \\--enable-jit \\--enable-jit-seallocmake &amp;&amp; make installexport PKG_CONFIG_PATH=/usr/local/pcre2/lib/pkgconfig/ 解决 libxml2 not found. Please check your libxml2 installation1yum install libxml2-devel 解决 configure: error: png.h not found12345678# 具体报错为：# If configure fails try --with-vpx-dir=&lt;DIR&gt;# If configure fails try --with-jpeg-dir=&lt;DIR&gt;# configure: error: png.h not found.# 解决命令：yum install libpngyum install libpng-devel 解决 configure: error: freetype-config not found123456# 具体报错为：# If configure fails try --with-xpm-dir=&lt;DIR&gt;#configure: error: freetype-config not found# 解决命令：yum install freetype-devel 解决 configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution1yum -y install libxslt libxslt-devel 解决 configure: error: Please reinstall the libzip distribution1234567891011121314151617# A.使用老版本 （长期合作战略合作伙伴提供技术支持）libzip-1.2.0wget https://nih.at/libzip/libzip-1.2.0.tar.gztar -zxvf libzip-1.2.0.tar.gzcd libzip-1.2.0./configuremake -j4 &amp;&amp; make install# B.使用最新版 （长期合作战略合作伙伴不提供技术支持**） libzip-1.5.2wget https://libzip.org/download/libzip-1.5.2.tar.gztar -zxf libzip-1.5.2.tar.gzcd libzip-1.5.2mkdir build cd build cmake .. （#注意：cmake后面有两个小数点）make -j4make testmake install cmake: 未找到命令解决方案123456789101112# 1. 官网下载cmake-3.12.2.tar.gzwget https://github.com/Kitware/CMake/releases/download/v3.13.2/cmake-3.13.2.tar.gz# 2. 解压到指定目录tar -zxvf cmake-3.13.2.tar.gz# 3、进入解压后的目录，依次运行指令cd cmake-3.13.2./bootstrap &amp;&amp; make &amp;&amp; make install# 4、查看版本信息：cmake -version","link":"/2021/01/20/php%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91/"},{"title":"js中连续复制的分析详解和创建链表","text":"1、var和let定义的差别123456789101112131415//var为全局定义变量，let为局部定义变量//一般Vue项目开发中推荐使用let定义变量，以防止变量污染var x = 100;let y = 100;{ var x = 200; let y = 200; console.log(&quot;x:&quot;+x, &quot;y:&quot;+y);//x:200 y:200}console.log(&quot;x:&quot;+x, &quot;y:&quot;+y);//x:200 y:100Object.getOwnPropertyDescriptor(globalThis, &quot;x&quot;);//{value: 200, writable: true, enumerable: true, configurable: false}Object.getOwnPropertyDescriptor(globalThis, &quot;y&quot;);//undefined 2、默认全局变量1234567891011121314151617181920212223//不进行声明的变量等价于var声明的全局变量，但不完全等价//1、进行var申明的变量会将变量名存入变量名列表//2、不进行声明的变量名不会存入变量名列表//不进行声明的变量在严格模式下会报错，项目中不建议使用x = 100;var y = 100;{ x = 200; var y = 200; z = 200; console.log(&quot;x:&quot;+x, &quot;y:&quot;+y);//x:200 y:200}console.log(&quot;x:&quot;+x, &quot;y:&quot;+y);//x:200 y:200console.log(&quot;x:&quot;+x, &quot;y:&quot;+y, &quot;z:&quot;+z,);//x:200 y:200 z:200Object.getOwnPropertyDescriptor(globalThis, &quot;x&quot;);//{value: 200, writable: true, enumerable: true, configurable: true}Object.getOwnPropertyDescriptor(globalThis, &quot;y&quot;);//{value: 200, writable: true, enumerable: true, configurable: false}//因为不进行声明的变量的configurable属性描述为true，意味着属性可修改，可执行delete操作delete x; //truedelete y; //false 3、等号连续赋值分析A、var x=y=100123456789//对于基本类型赋值的语句，没什么特别之处//关键注意点是=中间的变量是未声明的全局变量var x=y=100;//这个表达式等价于var x=100;y=100;//或者y=100;var x=y; B、node.next=node=new Object();12345678//1、场景1let node = {name:&quot;美男子&quot;};node.next = node;console.log(node); //{name: &quot;美男子&quot;, next: {name: &quot;美男子&quot;, next: {name: &quot;美男子&quot;, next: {…}}}}//执行如下图场景1所示//结论：这个现场从js的对象栈内存和堆内存存储角度就能理解 123456789//2、场景2let node = {name:&quot;美男子&quot;};node.next = node = {newName:&quot;我怎么这么好看！&quot;};console.log(node);//{newName: &quot;我怎么这么好看！&quot;}//按照表达式从左向右直行的原则，其相当于在场景1的基础上执行了node = {newName:&quot;我怎么这么好看！&quot;};//执行如下图场景2所示//注意：注意：注意：这样理解虽然能说明问题，然而理解的并不完整，存在错误！！！ 123456789101112131415161718192021222324//3、场景3//上面说场景2的解释理解并不完整，直接上代码先抛出问题let node = {name:&quot;美男子&quot;};let rootNode = node;for(let i=0; i&lt;3; i++){ node.next = node = {newName:&quot;我怎么这么好看！&quot;}; node.key = &quot;msj&quot; + (i + 1);}console.log(node);//{newName: &quot;我怎么这么好看！&quot;, key: &quot;msj3&quot;}console.log(rootNode);//结果如下图所示//{name: &quot;美男子&quot;, next: {newName: &quot;我怎么这么好看！&quot;, key: &quot;msj1&quot;, next: {newName: &quot;我怎么这么好看！&quot;, key: &quot;msj2&quot;, next: {newName: &quot;我怎么这么好看！&quot;, key: &quot;msj3&quot;}}}}//分析：此时你会发现，场景2中得出的结论并不能解释现在rootNode的结果。一直以来我们都只是在数据存储方面来理解，而并没有从代码运行解析层面去考虑，所以得到的思维模型并不完整。//结论：完整的理解这一运行结果需要三个知识点：//a、对象的堆存储//b、表达式的从左向右执行//c、执行赋值语句前，先要对=前后表达式做处理//因此`node.next = node = {newName:&quot;我怎么这么好看！&quot;}`这句的执行细节：//{newName:&quot;我怎么这么好看！&quot;}创建堆内存变量-&gt;node.next赋值指向新创建的堆内存变量-&gt;node赋值指向新创建的堆内存变量","link":"/2019/12/30/js%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%A4%8D%E5%88%B6%E7%9A%84%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8/"},{"title":"","text":"Linux系统常用指令12# 查询当前目录路径pwd","link":"/2023/02/03/Linux%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"","text":"conda使用笔记创建python虚拟环境 conda create -n [name] python=3.8 删除python虚拟环境 conda remove -n [name] –all 激活环境 conda activate [name] 查看环境下已有的安装包 conda list 退出当前python虚拟环境 conda deactivate 查看已有python虚拟环境 conda-env list","link":"/2023/01/13/conda%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"Aframe","slug":"Aframe","link":"/tags/Aframe/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"技术手册","slug":"技术手册","link":"/tags/%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"name":"MAC","slug":"MAC","link":"/tags/MAC/"},{"name":"操作手册","slug":"操作手册","link":"/tags/%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"UniApp","slug":"UniApp","link":"/tags/UniApp/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"nvm","slug":"nvm","link":"/tags/nvm/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"nrm","slug":"nrm","link":"/tags/nrm/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"半原生移动开发","slug":"半原生移动开发","link":"/tags/%E5%8D%8A%E5%8E%9F%E7%94%9F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"}],"categories":[{"name":"编程技术","slug":"编程技术","link":"/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"图形学","slug":"编程技术/图形学","link":"/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"pages":[]}